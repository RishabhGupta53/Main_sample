#Last Modification 19/02/2025
#Created by Luis Sandoval
#Calculating Tags and resources names calculation

function CalculateStorageAccountName {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string] $SubscriptionId
    )

    try {
        Write-Host "Processing StorageAccount..." -ForegroundColor Green

        # Import required modules
        $ModulePath = ".\Configuration\CommonFunctions\CommonFunctions.psm1"
        if (-not (Test-Path $ModulePath)) {
            throw "Module path not found: $ModulePath"
        }
        Import-Module $ModulePath -Force

        # Load configuration files
        $AppMetaDataPath = ".\Configuration\InitialProcess\AppMetadata.json"
        $BlobConfigPath = ".\Configuration\InitialProcess\Blob.json"
        
        if (-not (Test-Path $AppMetaDataPath)) {
            throw "AppMetadata.json not found at: $AppMetaDataPath"
        }
        if (-not (Test-Path $BlobConfigPath)) {
            throw "Blob.json not found at: $BlobConfigPath"
        }

        $AppMetaDataJson = Get-Content $AppMetaDataPath -Raw | ConvertFrom-Json
        $StorageBlob = Get-Content $BlobConfigPath -Raw | ConvertFrom-Json
        
        # Validate required properties
        $requiredProperties = @('Application_Name', 'Application_Code', 'Cloud_Provider', 'Environment', 'Entity')
        foreach ($prop in $requiredProperties) {
            if (-not $AppMetaDataJson.$prop) {
                throw "Missing required property in AppMetadata: $prop"
            }
        }

        $StorageMap = New-Object System.Collections.Generic.Dictionary"[String,Object]"
        $count = 0

        # Build tags array
        $tagsObject = $AppMetaDataJson | Select-Object -Property Resource_Description, CCoE_ID_Number, Application_Name, Entity, Organization, CHG_Ticket, Launch_Date, Deploy_Type -First 1
        
        # Get configuration values
        $applicationName = $AppMetaDataJson.Application_Name
        $applicationCode = $AppMetaDataJson.Application_Code
        $cloudProvider = Get-CloudProvider -Provider $AppMetaDataJson.Cloud_Provider
        $region = Get-AzRegion -Region $StorageBlob[0].AZ_Region
        $environment = Get-AzEnvironment -Environment $AppMetaDataJson.Environment
        $entity = $AppMetaDataJson.Entity
        $typeCode = "PRI"
        $resourceGroupName = "rg-$applicationName-$entity-$region-$environment-$typeCode"
        $currentDate = Get-Date -Format "dd/MM/yyyy"
        $resourceDescription = $StorageBlob[0].Resource_Description

        # Add additional properties to tags
        $tagsObject | Add-Member -MemberType NoteProperty -Name "Resource_Groups" -Value $resourceGroupName -Force
        $tagsObject | Add-Member -MemberType NoteProperty -Name "Launch_Date" -Value $currentDate -Force
        $tagsObject | Add-Member -MemberType NoteProperty -Name "Resource_Description" -Value $resourceDescription -Force

        $tagsArray = $tagsObject | ConvertTo-Json -Depth 100

        # Set redundancy based on environment
        $redundancy = if ($environment -eq "P") { "GRS" } else { "LRS" }

        # Set Azure context
        Set-AzContext -Subscription $SubscriptionId

        foreach ($item in $StorageBlob) {
            $count++
            $sequentialDigit = if ($count -gt 10) { $count } else { "0$count" }
            
            # Calculate Storage Account Name
            $storageAccountName = "$entity$applicationCode" + "STO$cloudProvider$environment$sequentialDigit"
            
            # Validate storage account name length and characters
            if ($storageAccountName.Length -gt 24 -or $storageAccountName.Length -lt 3) {
                Write-Warning "Storage account name length invalid: $storageAccountName"
                continue
            }

            # Create storage account object
            $sto = [StorageAccount]::new()
            $sto.name = $storageAccountName.ToLower()
            $sto.sto_region = $region
            $sto.account_tier = $item.Performance
            
            # Set kind based on account tier
            $sto.kind = if ($sto.account_tier -eq "Standard") { 
                "StorageV2" 
            } else { 
                $item."Premium account type" 
            }
            
            $sto.account_replication_type = $redundancy
            $sto.access_tier = $item.'Access tier'
            $sto.copy_scope = $item.'Permitted scope for copy operations (preview)'
            $sto.feed = [System.Convert]::ToBoolean($item.'Enable blob change feed')
            $sto.hns = [System.Convert]::ToBoolean($item.'Enable hierarchical namespace')
            $sto.infra_encrypt = [System.Convert]::ToBoolean($item.'Enable infrastructure encryption')
            $sto.nfs = [System.Convert]::ToBoolean($item.'Enable network file system v3')
            $sto.routing = $item.'Routing preference'
            $sto.sftp = [System.Convert]::ToBoolean($item.'Enable SFTP')
            $sto.tls = $item.'Minimum TLS version'
            $sto.versioning = [System.Convert]::ToBoolean($item.'Enable versioning for blobs')
            $sto.pep_subnet = $item.'Subnet For Private Endpoint'
            $sto.pep_vnet = $item.'Virtual Network Private Endpoint'
            $sto.static_website_enabled = $item.'Static Website Enabled'.ToLower()

            # Get VNet and Subnet information
            try {
                $vnetName = $item.'Virtual Network Private Endpoint'
                $subnetName = $item.'Subnet For Private Endpoint'
                
                $vnetQuery = Get-AzVirtualNetwork -Name $vnetName -ErrorAction Stop
                $vnetRG = $vnetQuery.ResourceGroupName
                $vnetCIDR = $vnetQuery.AddressSpace.AddressPrefixes
                
                Write-Host "VNET RG: $vnetRG" -ForegroundColor Yellow
                Write-Host "VNET CIDR: $vnetCIDR" -ForegroundColor Yellow
                
                $subnetQuery = Get-AzVirtualNetworkSubnetConfig -Name $subnetName -VirtualNetwork $vnetQuery -ErrorAction Stop
                $subnetCIDR = $subnetQuery.AddressPrefix
                
                Write-Host "Subnet Name: $subnetName" -ForegroundColor Yellow
                Write-Host "Subnet CIDR: $subnetCIDR" -ForegroundColor Yellow
                
                $sto.vnet_rg = $vnetRG
            }
            catch {
                Write-Error "Failed to get VNet/Subnet information for $vnetName/$subnetName : $_"
                continue
            }

            $StorageMap.Add("Storage_$count", $sto)
        }

        # Generate output
        $stoJson = $StorageMap | ConvertTo-Json -Depth 100
        $tfVarsFilePath = ".\Service\StorageAccount\Blob.tfvars"
        
        # Ensure directory exists
        $directory = Split-Path -Parent $tfVarsFilePath
        if (-not (Test-Path $directory)) {
            New-Item -ItemType Directory -Path $directory -Force
        }

        Set-Content $tfVarsFilePath "sto_tags = $tagsArray"
        Add-Content $tfVarsFilePath "StorageAccounts = $stoJson"
        
        Write-Host "Successfully generated $($StorageMap.Count) storage account configurations" -ForegroundColor Green
        Write-Host "Output written to: $tfVarsFilePath" -ForegroundColor Green
    }
    catch {
        Write-Error "Error in CalculateStorageAccountName: $_"
        throw
    }
}

class StorageAccount {
    [string] $name
    [string] $sto_region
    [string] $account_tier
    [string] $account_replication_type
    [string] $access_tier
    [string] $copy_scope
    [bool] $feed
    [bool] $hns
    [bool] $infra_encrypt
    [string] $kind
    [bool] $nfs
    [string] $routing
    [bool] $sftp
    [string] $tls
    [bool] $versioning
    [string] $pep_subnet
    [string] $pep_vnet
    [string] $vnet_rg
    [string] $static_website_enabled
}

Export-ModuleMember -Function CalculateStorageAccountName
